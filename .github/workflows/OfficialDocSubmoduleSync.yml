# -------------------------------------------------------------------
# This workflow file is dedicated to the public domain under CC0 1.0.
# See https://creativecommons.org/publicdomain/zero/1.0/
# -------------------------------------------------------------------
# 更新SEVETEST30的官方文档子模块,仅在文档同步可复用工作流成功完成后触发
# 考虑到未来官方文档可能不限于Doxygen生成文档,相关业务代码为动态输入参数运行,后续只需更改下方触发条件即可

# 以下是通过Doxygen自动生成官方文档的相关工作全流程(仅针对关键分支,如分支A)
# SEVETEST30仓库关键分支A的push
# -> DoxygenAutoDocSync触发
# -> DoxygenAutoDocSync调用doxygen-auto-code-to-doc
# -> doxygen-auto-code-to-doc触发,根据A分支代码生成文档并将更改推送到文档仓库的A分支
# (doxygen-auto-code-to-doc结束)
# -> DoxygenAutoDocSync调用OfficialDocSubmoduleSync
# -> OfficialDocSubmoduleSync触发,更新子模块,将更改推送到A分支的机器人分支并发起该分支到A分支的PR
# (OfficialDocSubmoduleSync结束)
# (DoxygenAutoDocSync结束)
# -> PR审查 -> 完成
# [注意: SEVETEST30仓库是将每个文档仓库作为子模块独立管理的,子模块名必须与文档仓库名一致]

# 文档生成和推送工作使用可复用工作流: https://github.com/701Enti/Github-WorkFlows/blob/master/.github/workflows/doxygen-auto-code-to-doc.yml (它存储在 701Enti 的专门工作流文件存储库)

# 为保证资源充足,只会为关键分支提供自动文档生成,具体会触发工作流的关键分支在下方"on"中可设置和查看
# 值得声明的是, SEVETEST30 文档仓库不是私有仓库,您完全可以push个人分支生成的文档到独立分支,甚至可以是您对SEVETEST30的见解等其他任何与SEVETEST30相关的内容,只要您没有影响自动文档或进行不合理的推送
# 当然,如果您希望自己的分支像关键分支一样可云端部署文档,您可以在本地运行 Doxygen 生成文档,并推送到 SEVETEST30 文档仓库与个人分支同名的分支,之后可联系 SEVETEST30 团队协商,他们管理文档的云端部署
# 更多信息可参考项目根目录README.md文件 - 文档相关
name: OfficialDocSubmoduleSync
on:
  workflow_call:
    inputs:
      owner:
        description: "the name of code repository owner"
        required: true
        type: string
      codeRepoName:
        description: "the name of code repository"
        required: true
        type: string
      docRepoName:
        description: "the name of document repository (the submodule name in code repository)"
        required: true
        type: string
      UPDATE_BRANCH:
        description: "the branch to update in code repository"
        required: true
        type: string

permissions:
  pull-requests: write
  contents: write

jobs:
  information_collect:
    timeout-minutes: 30
    runs-on: ubuntu-latest
    outputs:
      owner: ${{ steps.extract.outputs.owner }}
      codeRepoName: ${{ steps.extract.outputs.codeRepoName }}
      docRepoName: ${{ steps.extract.outputs.docRepoName }}
      UPDATE_BRANCH: ${{ steps.extract.outputs.UPDATE_BRANCH }}
      ROBOT_UPDATE_BRANCH: ${{ steps.extract.outputs.ROBOT_UPDATE_BRANCH }}
      robot_branch_exists: ${{ steps.extract.outputs.robot_branch_exists }}
    steps:
      - name: Extract context information
        id: extract
        run: |
          owner="${{ inputs.owner }}"
          echo "owner=${owner}" >> $GITHUB_OUTPUT
          codeRepoName="${{ inputs.codeRepoName }}"
          echo "codeRepoName=${codeRepoName}" >> $GITHUB_OUTPUT
          docRepoName="${{ inputs.docRepoName }}"
          echo "docRepoName=${docRepoName}" >> $GITHUB_OUTPUT
          UPDATE_BRANCH="${{ inputs.UPDATE_BRANCH }}"
          echo "UPDATE_BRANCH=${UPDATE_BRANCH}" >> $GITHUB_OUTPUT
          ROBOT_UPDATE_BRANCH="OfficialDocRobot-${docRepoName}-${UPDATE_BRANCH}"
          echo "ROBOT_UPDATE_BRANCH=${ROBOT_UPDATE_BRANCH}" >> $GITHUB_OUTPUT
          branch_exists=$(git ls-remote --heads "https://github.com/${owner}/${codeRepoName}.git" "${ROBOT_UPDATE_BRANCH}")
          if [ -n "$branch_exists" ]; then
            echo "robot_branch_exists=true" >> $GITHUB_OUTPUT
          else
            echo "robot_branch_exists=false" >> $GITHUB_OUTPUT  
          fi

  robot_branch_exists_false:
    runs-on: ubuntu-latest
    needs: information_collect
    if: ${{ needs.information_collect.outputs.robot_branch_exists == 'false' }}
    steps:
      - name: Wait for document repository push to complete
        run: sleep 30

      - name: Checkout with submodules
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Checkout robot branch
        run: |
          git checkout -b "${{ needs.information_collect.outputs.ROBOT_UPDATE_BRANCH }}" "${{ needs.information_collect.outputs.UPDATE_BRANCH }}"

      - name: Update Submodule
        run: |
          rm -rf ".git/modules/docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}"
          rm -rf "docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}"
          git submodule update --init --remote --force -- "docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}"

      - name: Run tar to pack all
        run: tar czf before_code_repo_push.tar.gz . || true
        
      - name: Upload artifact (before_code_repo_push) 
        uses: actions/upload-artifact@v4
        with:
          name: before_code_repo_push
          path: before_code_repo_push.tar.gz

      - name: Delete temporary file
        run: rm before_code_repo_push.tar.gz

      - name: Push changes to code repository
        id: push_changes
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_DOC_SYNC_SECRET }}
          DOC_REPO_NAME: ${{ needs.information_collect.outputs.docRepoName }}
          ROBOT_UPDATE_BRANCH: ${{ needs.information_collect.outputs.ROBOT_UPDATE_BRANCH }}
        run: |
          NEW_DOC_COMMIT_SHA=$(git -C "docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}" rev-parse --short HEAD)
          echo "NEW_DOC_COMMIT_SHA=${NEW_DOC_COMMIT_SHA}" >> $GITHUB_OUTPUT
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "docs/official/repo_doc/${DOC_REPO_NAME}"
          git commit -m "(New Robot branch)Update documentation ${DOC_REPO_NAME} | ${NEW_DOC_COMMIT_SHA} "
          git push -u origin $ROBOT_UPDATE_BRANCH

      - name: Wait for code repository push to complete
        run: sleep 30

      - name: Create PR 
        env:
          GH_TOKEN: ${{ secrets.ORG_DOC_SYNC_SECRET }}
          DOC_REPO_NAME: ${{ needs.information_collect.outputs.docRepoName }}
          ROBOT_UPDATE_BRANCH: ${{ needs.information_collect.outputs.ROBOT_UPDATE_BRANCH }}
          UPDATE_BRANCH: ${{ needs.information_collect.outputs.UPDATE_BRANCH }}
          NEW_DOC_COMMIT_SHA: ${{ steps.push_changes.outputs.NEW_DOC_COMMIT_SHA }}
          WORKFLOW: ${{ github.workflow }}
          RUN_ID: ${{ github.run_id }}
        run: |
          gh pr create \
            --title "(New Robot branch)Update documentation ${DOC_REPO_NAME} | ${NEW_DOC_COMMIT_SHA}" \
            --base ${UPDATE_BRANCH} \
            --head ${ROBOT_UPDATE_BRANCH} \
            --body "The pull&request is created by ${WORKFLOW} [run_id: - ${RUN_ID}]" \
            --label "document,robot,automation"

  robot_branch_exists_true:
    runs-on: ubuntu-latest
    needs: information_collect
    if: ${{ needs.information_collect.outputs.robot_branch_exists == 'true' }}
    steps:
      - name: Wait for document repository push to complete
        run: sleep 30

      - name: Checkout with submodules
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Checkout robot branch
        run: |
          git checkout -b "${{ needs.information_collect.outputs.ROBOT_UPDATE_BRANCH }}" "${{ needs.information_collect.outputs.UPDATE_BRANCH }}"

      - name: Update Submodule
        run: |
          rm -rf ".git/modules/docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}"
          rm -rf "docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}"
          git submodule update --init --remote --force -- "docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}"

      - name: Run tar to pack all
        run: tar czf before_code_repo_push.tar.gz . || true
        
      - name: Upload artifact (before_code_repo_push) 
        uses: actions/upload-artifact@v4
        with:
          name: before_code_repo_push
          path: before_code_repo_push.tar.gz

      - name: Delete temporary file
        run: rm before_code_repo_push.tar.gz

      - name: Push changes to code repository
        id: push_changes
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_DOC_SYNC_SECRET }}
          DOC_REPO_NAME: ${{ needs.information_collect.outputs.docRepoName }}
          ROBOT_UPDATE_BRANCH: ${{ needs.information_collect.outputs.ROBOT_UPDATE_BRANCH }}
        run: |
          NEW_DOC_COMMIT_SHA=$(git -C "docs/official/repo_doc/${{ needs.information_collect.outputs.docRepoName }}" rev-parse --short HEAD)
          echo "NEW_DOC_COMMIT_SHA=${NEW_DOC_COMMIT_SHA}" >> $GITHUB_OUTPUT
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "docs/official/repo_doc/${DOC_REPO_NAME}"
          git commit -m "(New Robot branch)Update documentation ${DOC_REPO_NAME} | ${NEW_DOC_COMMIT_SHA} "
          git push origin --delete $ROBOT_UPDATE_BRANCH 
          git push -u origin $ROBOT_UPDATE_BRANCH

      - name: Wait for code repository push to complete
        run: sleep 30

      - name: Create PR 
        env:
          GH_TOKEN: ${{ secrets.ORG_DOC_SYNC_SECRET }}
          DOC_REPO_NAME: ${{ needs.information_collect.outputs.docRepoName }}
          ROBOT_UPDATE_BRANCH: ${{ needs.information_collect.outputs.ROBOT_UPDATE_BRANCH }}
          UPDATE_BRANCH: ${{ needs.information_collect.outputs.UPDATE_BRANCH }}
          NEW_DOC_COMMIT_SHA: ${{ steps.push_changes.outputs.NEW_DOC_COMMIT_SHA }}
          WORKFLOW: ${{ github.workflow }}
          RUN_ID: ${{ github.run_id }}
        run: |
          gh pr create \
            --title "(New Robot branch)Update documentation ${DOC_REPO_NAME} | ${NEW_DOC_COMMIT_SHA}" \
            --base ${UPDATE_BRANCH} \
            --head ${ROBOT_UPDATE_BRANCH} \
            --body "The pull&request is created by ${WORKFLOW} [run_id: - ${RUN_ID}]" \
            --label "document,robot,automation"
